package com.example.keepnotes.data.repository

import com.example.keepnotes.data.local.NoteDatabase
import com.example.keepnotes.domain.model.Note
import com.example.keepnotes.domain.model.RealtimeModelResponse
import com.example.keepnotes.domain.model.ResultState
import com.example.keepnotes.domain.repository.LocalDataSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.emitAll
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map






class LocalDataSourceImpl(
    private val noteDatabase: NoteDatabase
) : LocalDataSource {

    override fun insertNote(item: RealtimeModelResponse.RealtimeItems): Flow<ResultState<String>> = flow {
        try {
            emit(ResultState.Loading)

            // Convert RealtimeModelResponse.RealtimeItems to Note entity
            val note = Note(
                id = 0, // Assuming ID is autogenerated
                title = item.title ?: "",
                note = item.note ?: "",
                category = item.category ?: "" // Add category property

            )

            // Insert note into Room database
            noteDatabase.noteDao().insertNote(note)

            emit(ResultState.Success("Data inserted Successfully..."))
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }




    override fun getAllNote(): Flow<ResultState<List<RealtimeModelResponse>>> = flow {
        emit(ResultState.Loading)
        try {
            val notes = noteDatabase.noteDao().getAllNote()
            emitAll(
                notes.map { noteList ->
                    val items = noteList.map { note ->
                        RealtimeModelResponse(
                            item = RealtimeModelResponse.RealtimeItems(
                                title = note.title,
                                note = note.note,
                                category = note.category // Add category property
                            ),
                            key = note.id.toString()
                        )
                    }
                    ResultState.Success(items)
                }
            )
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }



    override fun getNote(key: String): Flow<ResultState<RealtimeModelResponse>> = flow {
        emit(ResultState.Loading)
        try {
            val noteId = key.toIntOrNull() ?: throw IllegalArgumentException("Invalid key")
            val note = noteDatabase.noteDao().getNote(noteId)
            emitAll(
                note.map { note ->
                    ResultState.Success(
                        RealtimeModelResponse(
                            item = RealtimeModelResponse.RealtimeItems(
                                title = note.title,
                                note = note.note,
                                category = note.category // Add category property
                            ),
                            key = note.id.toString()
                        )
                    )
                }
            )
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }


//    override fun deleteNote(key: String): Flow<ResultState<String>> = flow {
//        emit(ResultState.Loading)
//        try {
//            val noteId = key.toIntOrNull() ?: throw IllegalArgumentException("Invalid key")
//            val note = noteDatabase.noteDao().getNote(noteId)
//            note.collect { noteToDelete ->
//                if (noteToDelete != null) {
//                    noteDatabase.noteDao().deleteNote(noteToDelete)
//                    emit(ResultState.Success("Delete successfully..."))
//                } else {
//                    emit(ResultState.Failure(Exception("Note not found")))
//                }
//            }
//        } catch (e: Exception) {
//            emit(ResultState.Failure(e))
//        }
//    }.flowOn(Dispatchers.IO)


    override fun deleteNote(key: String, category: String): Flow<ResultState<String>> = flow {
        emit(ResultState.Loading)
        try {
            val noteId = key.toIntOrNull() ?: throw IllegalArgumentException("Invalid key")
            val note = noteDatabase.noteDao().getNote(noteId)
            note.collect { noteToModify ->
                if (noteToModify != null) {
                    noteToModify.category = category // Set the category to "deleted" or "archived"
                    noteDatabase.noteDao().updateNote(noteToModify) // Update the note in the database
                    emit(ResultState.Success("Note moved to deleted category..."))
                } else {
                    emit(ResultState.Failure(Exception("Note not found")))
                }
            }
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }.flowOn(Dispatchers.IO)


    override fun archiveNote(key: String): Flow<ResultState<String>> = flow {
        emit(ResultState.Loading)
        try {
            val noteId = key.toIntOrNull() ?: throw IllegalArgumentException("Invalid key")
            val note = noteDatabase.noteDao().getNote(noteId)
            note.collect { noteToModify ->
                if (noteToModify != null) {
                    noteToModify.category = "archived" // Set the category to "archived"
                    noteDatabase.noteDao().updateNote(noteToModify) // Update the note in the database
                    emit(ResultState.Success("Note moved to deleted category..."))
                } else {
                    emit(ResultState.Failure(Exception("Note not found")))
                }
            }
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }.flowOn(Dispatchers.IO)






    override fun updateNote(res: RealtimeModelResponse): Flow<ResultState<String>> = flow {
        emit(ResultState.Loading)
        try {
            val noteId = res.key?.toIntOrNull() ?: throw IllegalArgumentException("Invalid key")
            val note = noteDatabase.noteDao().getNote(noteId)
            note.collect { noteToUpdate ->
                if (noteToUpdate != null) {
                    val updatedNote = noteToUpdate.copy(
                        title = res.item?.title ?: noteToUpdate.title,
                        note = res.item?.note ?: noteToUpdate.note,
                        category = res.item?.category ?: noteToUpdate.category // Add this line to update category
                    )
                    noteDatabase.noteDao().updateNote(updatedNote)
                    emit(ResultState.Success("Update successfully..."))
                } else {
                    emit(ResultState.Failure(Exception("Note not found")))
                }
            }
        } catch (e: Exception) {
            emit(ResultState.Failure(e))
        }
    }.flowOn(Dispatchers.IO)



    override fun getUpdatedNotes(): List<RealtimeModelResponse> {
        // Return the list of updated notes
        return listOf()
    }

}